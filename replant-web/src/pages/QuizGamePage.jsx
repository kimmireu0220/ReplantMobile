import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { tokens } from '../design/tokens';
import { Progress, ToastContainer } from '../components/ui';
import { useToast } from '../hooks';
import { gameService } from '../services';
import quizQuestionsData, { quizQuestions } from '../data/quizQuestions';

const QUESTION_TIME = 15; // Ï¥à

const QuizGamePage = () => {
  // Ïú†Ìã∏: Î∞∞Ïó¥ ÏÖîÌîå (Fisher‚ÄìYates)
  const shuffleArray = useCallback((array) => {
    const arr = array.slice();
    for (let i = arr.length - 1; i > 0; i -= 1) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }, []);

  // ÏßàÎ¨∏ Îç∞Ïù¥ÌÑ∞ (Ï†ïÏ†Å) + Î≥¥Í∏∞ ÏÖîÌîå Î∞è Ï†ïÎãµ Ïù∏Îç±Ïä§ Ïû¨Í≥ÑÏÇ∞ (Ï¥àÍ∏∞ 1Ìöå)
  const questions = useMemo(() => {
    const base = quizQuestionsData || quizQuestions || [];
    const shuffledQuestions = shuffleArray(base);
    return shuffledQuestions.map((q) => {
      const optionIdx = q.options.map((_, idx) => idx);
      const shuffledIdx = shuffleArray(optionIdx);
      const shuffledOptions = shuffledIdx.map((i) => q.options[i]);
      const newAnswerIndex = shuffledIdx.indexOf(q.answerIndex);
      return {
        ...q,
        options: shuffledOptions,
        answerIndex: newAnswerIndex,
      };
    });
  }, [shuffleArray]);

  // ÏÉÅÌÉú
  const [currentIndex, setCurrentIndex] = useState(0);
  const [selected, setSelected] = useState(null);
  const [score, setScore] = useState(0);
  const [streak, setStreak] = useState(0);
  const [timeLeft, setTimeLeft] = useState(QUESTION_TIME);
  const [gameOver, setGameOver] = useState(false);
  const [highScore, setHighScore] = useState(0);
  const [isHighScoreLoaded, setIsHighScoreLoaded] = useState(false);
  const [isLocked, setIsLocked] = useState(false); // Ï†ÑÌôò/Ï±ÑÏ†ê Ï§ë ÏûÖÎ†• Ïû†Í∏à
  const [focusedIndex, setFocusedIndex] = useState(-1); // ÌÇ§Î≥¥Îìú Ìè¨Ïª§Ïä§Ïö© Ïù∏Îç±Ïä§ (Ï¥àÍ∏∞ ÏãúÍ∞Å Í∞ïÏ°∞ ÏóÜÏùå)
  const startedAtRef = useRef(Date.now());
  const timerRef = useRef(null);

  const { toasts, showSuccess, showError, removeToast } = useToast();

  // ÏµúÍ≥† Ï†êÏàò Î°úÎìú
  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const s = await gameService.getHighScore('quiz');
        if (mounted) setHighScore(s || 0);
      } catch (_) {
        // noop
      } finally {
        if (mounted) setIsHighScoreLoaded(true);
      }
    })();
    return () => { mounted = false; };
  }, []);

  // ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ï
  const clearTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  };

  // handleAnswer ÏµúÏã† Ï∞∏Ï°∞Î•º ÏúÑÌïú ref
  const handleAnswerRef = useRef(() => {});

  // handleAnswerÎäî ÏïÑÎûòÏóêÏÑú Ï†ïÏùòÎêòÎØÄÎ°ú Ïù¥ ÌõÖÏùÄ Ï†ïÏùò Ïù¥ÌõÑÏóê Ïã§ÌñâÎêòÏñ¥ ÏµúÏã† Ï∞∏Ï°∞Î•º Ï†ÄÏû•ÌïúÎã§
  useEffect(() => {
    handleAnswerRef.current = (choiceIndex, isTimeOut) => handleAnswer(choiceIndex, isTimeOut);
  });

  const startTimer = useCallback(() => {
    clearTimer();
    setTimeLeft(QUESTION_TIME);
    timerRef.current = setInterval(() => {
      setTimeLeft((t) => {
        if (t <= 1) {
          // ÏãúÍ∞Ñ Ï¥àÍ≥º ‚Üí Ïò§Îãµ Ï≤òÎ¶¨ ÌõÑ Îã§Ïùå Î¨∏Ï†ú
          clearTimer();
          handleAnswerRef.current(null, true);
          return 0;
        }
        return t - 1;
      });
    }, 1000);
  }, []);

  useEffect(() => {
    if (!gameOver && questions.length > 0) {
      startTimer();
    }
    return clearTimer;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentIndex, gameOver, questions.length, startTimer]);

  // Ï±ÑÏ†ê Î∞è Îã§Ïùå ÏßÑÌñâ
  const goNext = useCallback(() => {
    setSelected(null);
    setIsLocked(false);
    setFocusedIndex(-1);
    if (currentIndex + 1 >= questions.length) {
      setGameOver(true);
      clearTimer();
    } else {
      setCurrentIndex((i) => i + 1);
    }
  }, [currentIndex, questions.length]);

  const handleAnswer = useCallback((choiceIndex, isTimeOut = false) => {
    if (isLocked || gameOver) return;
    setIsLocked(true);
    const q = questions[currentIndex];
    const isCorrect = choiceIndex !== null && choiceIndex === q.answerIndex;
    setSelected(choiceIndex);

    setScore((prev) => {
      if (isCorrect) {
        // const nextStreak = streak + 1;
        const bonus = 20 * streak; // ÏßÅÏ†Ñ Ïó∞ÏÜçÏàò Í∏∞Î∞ò Î≥¥ÎÑàÏä§
        return prev + 100 + bonus;
      }
      return prev;
    });
    setStreak((prev) => (isCorrect ? prev + 1 : 0));

    // 800ms ÌõÑ Îã§Ïùå Î¨∏Ï†úÎ°ú Ïù¥Îèô
    setTimeout(() => {
      goNext();
    }, 800);
  }, [questions, currentIndex, goNext, isLocked, gameOver, streak]);

  // Ïû¨ÏãúÏûë Ìï∏Îì§Îü¨ (Îã§Î•∏ Í≤åÏûÑÍ≥º ÌÜµÏùº: Ïò§Î≤ÑÎ†àÏù¥ ÌÅ¥Î¶≠ÏúºÎ°ú Ïû¨ÏãúÏûë)
  const restartGame = useCallback(() => {
    startedAtRef.current = Date.now();
    setCurrentIndex(0);
    setSelected(null);
    setScore(0);
    setStreak(0);
    setTimeLeft(QUESTION_TIME);
    setGameOver(false);
    setIsLocked(false);
  }, []);

  // Í≤åÏûÑ Ï¢ÖÎ£å Ïãú Í∏∞Î°ù Ï†ÄÏû•
  useEffect(() => {
    const saveOnEnd = async () => {
      if (!gameOver) return;
      try {
        const durationMs = Math.max(0, Date.now() - startedAtRef.current);
        const result = await gameService.saveAndCheckRecord('quiz', {
          score,
          durationMs,
        });
        if (result.success && result.isNewHigh) {
          setHighScore(score);
          showSuccess(`üéâ ÏÉàÎ°úÏö¥ ÏµúÍ≥† Í∏∞Î°ù Îã¨ÏÑ±! ${score}Ï†ê`);
        }
      } catch (error) {
        showError('Í∏∞Î°ù Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
      }
    };
    saveOnEnd();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [gameOver]);

  // ÏïàÏ†Ñ Î¶¨ÏÖã: Î¨∏Ìï≠ Î≥ÄÍ≤Ω Ïãú ÏÑ†ÌÉù/Ïû†Í∏à/Ìè¨Ïª§Ïä§ Ï¥àÍ∏∞Ìôî (Í≤ΩÏüÅ Ï°∞Í±¥ Î∞©ÏßÄ)
  useEffect(() => {
    setSelected(null);
    setIsLocked(false);
    setFocusedIndex(-1);
  }, [currentIndex]);

  // UI Ïä§ÌÉÄÏùº
  const pageStyle = {
    minHeight: '100vh',
    backgroundColor: tokens.colors.background.primary,
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    padding: tokens.spacing[4]
  };

  const containerStyle = {
    width: '100%',
    maxWidth: '560px',
    backgroundColor: tokens.colors.background.secondary,
    border: `1px solid ${tokens.colors.border.primary}`,
    borderRadius: tokens.borderRadius.lg,
    padding: tokens.spacing[6],
    boxShadow: tokens.shadow.base
  };

  const headerStyle = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    gap: tokens.spacing[2],
    marginBottom: tokens.spacing[4]
  };

  const titleStyle = {
    fontSize: tokens.typography.fontSize['2xl'],
    fontWeight: tokens.typography.fontWeight.bold,
    color: tokens.colors.text.primary
  };

  const subTextStyle = {
    fontSize: tokens.typography.fontSize.sm,
    color: tokens.colors.text.secondary
  };

  const questionStyle = {
    fontSize: tokens.typography.fontSize.lg,
    color: tokens.colors.text.primary,
    fontWeight: tokens.typography.fontWeight.semibold,
    marginBottom: tokens.spacing[4]
  };

  const optionsStyle = {
    display: 'grid',
    gridTemplateColumns: '1fr',
    gap: tokens.spacing[3],
    marginBottom: tokens.spacing[4]
  };

  const footerStyle = {
    display: 'flex',
    flexDirection: 'column',
    gap: tokens.spacing[2]
  };

  // const percent = questions.length > 0 ? Math.round(((currentIndex) / questions.length) * 100) : 0;
  const timePercent = Math.round((timeLeft / QUESTION_TIME) * 100);

  const currentQuestion = questions[currentIndex];

  // ÏÑ∏Í∑∏Î®ºÌä∏Ìòï ÏßÑÌñâÎ∞î
  const SegmentedProgress = ({ current, total }) => {
    const count = Math.max(0, total);
    const segments = Array.from({ length: count }, (_, i) => i);
    const containerStyle = {
      display: 'flex',
      gap: 4,
      width: '100%',
      marginBottom: tokens.spacing[1],
    };
    const baseStyle = {
      height: 8,
      borderRadius: tokens.borderRadius.full,
      flex: 1,
      transition: 'background-color 150ms ease',
      backgroundColor: tokens.colors.gray[200],
    };
    const doneStyle = { backgroundColor: tokens.colors.primary[500] };
    const currentStyle = { backgroundColor: tokens.colors.primary[600] };
    return (
      <div
        style={containerStyle}
        role="progressbar"
        aria-valuenow={Math.min(current + 1, total)}
        aria-valuemin={0}
        aria-valuemax={total}
        aria-label="ÌÄ¥Ï¶à ÏßÑÌñâÎèÑ"
      >
        {segments.map((i) => {
          const style = i < current ? { ...baseStyle, ...doneStyle } : i === current ? { ...baseStyle, ...currentStyle } : baseStyle;
          return <div key={i} style={style} />;
        })}
      </div>
    );
  };

  // ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò: ÌôîÏÇ¥ÌëúÎ°ú Î≥¥Í∏∞ Ïù¥Îèô, Enter/SpaceÎ°ú ÏÑ†ÌÉù
  const handleKeyDown = useCallback((e) => {
    if (gameOver || !currentQuestion) return;
    const len = currentQuestion.options.length;
    if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
      e.preventDefault();
      setFocusedIndex((idx) => Math.max(0, idx - 1));
    } else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
      e.preventDefault();
      setFocusedIndex((idx) => Math.min(len - 1, idx + 1));
    } else if ((e.key === 'Enter' || e.key === ' ') && selected === null && !isLocked) {
      e.preventDefault();
      handleAnswer(focusedIndex);
    }
  }, [currentQuestion, focusedIndex, handleAnswer, isLocked, selected, gameOver]);

  return (
    <div style={pageStyle}>
      <main
        style={containerStyle}
        role="main"
        tabIndex={0}
        onKeyDown={handleKeyDown}
        aria-label="ÌÄ¥Ï¶à Í≤åÏûÑ ÏòÅÏó≠"
      >
        {/* Ìó§Îçî */}
        <div style={headerStyle}>
          <div style={titleStyle}>üí° ÌÄ¥Ï¶à Í≤åÏûÑ</div>
          {isHighScoreLoaded && (
            <div style={subTextStyle} aria-live="polite">ÏµúÍ≥† Ï†êÏàò: {highScore.toLocaleString()}Ï†ê</div>
          )}
        </div>

        {/* ÏßÑÌñâÎèÑ */}
        <div style={{ marginBottom: tokens.spacing[2] }}>
          <SegmentedProgress current={currentIndex} total={questions.length} />
          <div style={subTextStyle} aria-live="polite">{currentIndex + 1} / {questions.length}</div>
        </div>

        {/* ÏßàÎ¨∏ */}
        {currentQuestion ? (
          <div key={currentQuestion.id}>
            <div style={questionStyle}>{currentQuestion.question}</div>
            <div style={optionsStyle} role="group" aria-label="ÏÑ†ÌÉùÏßÄ">
              {currentQuestion.options.map((opt, idx) => {
                // const isFocused = selected === null && idx === focusedIndex;
                const isSelected = selected === idx;
                const isCorrectOption = idx === currentQuestion.answerIndex;
                const showingFeedback = selected !== null; // ÌôïÏ†ï ÌõÑ 800ms ÎèôÏïà

                // Ïä§ÌÉÄÏùº Í≥ÑÏÇ∞ (ÏÑ†ÌÉù Ï†Ñ: ÌÜµÏùº, ÏÑ†ÌÉù ÌõÑ: Ï†ïÎãµ/Ïò§Îãµ ÌîºÎìúÎ∞±)
                let borderColor = tokens.colors.border.primary;
                let bg = tokens.colors.background.primary;

                if (showingFeedback) {
                  if (isCorrectOption) {
                    borderColor = tokens.colors.success;
                    bg = 'rgba(34, 197, 94, 0.12)'; // success ÎùºÏù¥Ìä∏
                  } else if (isSelected) {
                    borderColor = tokens.colors.error;
                    bg = 'rgba(239, 68, 68, 0.12)'; // error ÎùºÏù¥Ìä∏
                  }
                }
                return (
                  <button
                    key={idx}
                    type="button"
                    onClick={() => handleAnswer(idx)}
                    disabled={selected !== null || isLocked}
                    style={{
                      textAlign: 'left',
                      padding: tokens.spacing[3],
                      borderRadius: tokens.borderRadius.md,
                      border: `2px solid ${borderColor}`,
                      backgroundColor: bg,
                      cursor: selected !== null || isLocked ? 'default' : 'pointer',
                      fontSize: tokens.typography.fontSize.base,
                      color: tokens.colors.text.primary,
                      transition: 'all 150ms ease'
                    }}
                    aria-pressed={selected === idx}
                    aria-current={undefined}
                    tabIndex={-1}
                  >
                    {opt}
                  </button>
                );
              })}
            </div>

            {/* ÌïòÎã® Ï†ïÎ≥¥ */}
            <div style={footerStyle}>
              <div aria-live="polite" style={subTextStyle}>Ï†êÏàò: {score.toLocaleString()}Ï†ê</div>
              <div style={{ display: 'flex', alignItems: 'center', gap: tokens.spacing[2] }}>
                <div style={{ minWidth: 64, ...subTextStyle }}>ÎÇ®ÏùÄ ÏãúÍ∞Ñ</div>
                <div style={{ flex: 1 }}>
                  <Progress value={timePercent} max={100} color={timePercent <= 20 ? '#EF4444' : tokens.colors.primary[500]} ariaLabel="ÎÇ®ÏùÄ ÏãúÍ∞Ñ" />
                </div>
                <div style={{ minWidth: 40, textAlign: 'right', ...subTextStyle }}>{timeLeft}s</div>
              </div>
            </div>
          </div>
        ) : (
          <div style={subTextStyle}>Î¨∏Ìï≠ÏùÑ Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.</div>
        )}
      </main>

      {/* Í≤åÏûÑ Ïò§Î≤Ñ Ïò§Î≤ÑÎ†àÏù¥ (Îã§Î•∏ Í≤åÏûÑÍ≥º ÌÜµÏùº) */}
      {gameOver && (
        <div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(17, 24, 39, 0.45)',
            backdropFilter: 'blur(6px)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: tokens.zIndex.modal,
          }}
          role="dialog"
          aria-modal="true"
          aria-label="Game Over"
          onClick={restartGame}
        >
          <div style={{
            backgroundColor: 'transparent',
            padding: tokens.spacing[8],
            borderRadius: tokens.borderRadius.lg,
            textAlign: 'center',
            maxWidth: '420px',
            width: '92%',
            boxShadow: 'none',
            border: 'none'
          }}>
            <div style={{
              fontSize: tokens.typography.fontSize['4xl'],
              fontWeight: tokens.typography.fontWeight.bold,
              marginBottom: tokens.spacing[4],
              color: tokens.colors.text.inverse,
              textShadow: '0 2px 8px rgba(0,0,0,0.55), 0 1px 2px rgba(0,0,0,0.35)'
            }}>
              Game Over
            </div>
            <div style={{
              display: 'inline-block',
              fontSize: tokens.typography.fontSize.xl,
              color: tokens.colors.text.inverse,
              fontWeight: tokens.typography.fontWeight.semibold,
              textShadow: '0 1px 3px rgba(0,0,0,0.45)'
            }}>
              Îã§Ïãú ÏãúÏûë
            </div>
          </div>
        </div>
      )}

      {/* ÌÜ†Ïä§Ìä∏ */}
      <ToastContainer toasts={toasts} removeToast={removeToast} />
    </div>
  );
};

export default QuizGamePage;